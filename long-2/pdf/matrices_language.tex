\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{hyperref}

\usepackage[top=2cm,bottom=3cm,left=2cm,right=2cm,nohead]{geometry}
\usepackage{indentfirst}

%
% МОДИФИКАЦИЯ ОФОРМЛЕНИЯ НУМЕРАЦИИ РАЗДЕЛОВ -------------------------------
%
%\renewcommand{\thechapter}{\arabic{chapter}}
\renewcommand{\thesection}{\arabic{section}.}
\renewcommand{\thesubsection}{\thesection\arabic{subsection}.}
\renewcommand{\thesubsubsection}{\thesubsection\arabic{subsubsection}.}
\renewcommand{\theparagraph}{\thesubsubsection\arabic{paragraph}.}



\usepackage{color}

%
% Описание команды для отображения пустой
% цепочки
%
\newcommand{\eps}{\varepsilon}

%
% Команда для отображения 
% нетерминального символа. 
% Он голубеньким подсвечивается
%
\newcommand{\ns}[1]{\textcolor{blue}{<#1>}}
\newcommand{\ls}[1]{\textcolor{red}{<#1>}}

%
% Терминал, он просто чёрный
%
\newcommand{\ts}[1]{<#1>}




\usepackage{listings}
\lstset{language=c++, extendedchars=\true}

\usepackage{verbatim}


\title{Язык для реализации матричных выражений}
\author{Алексей Сальников}
\date{2018}

\begin{document}

\maketitle

\section{Введение}

Требуется написать программу, которая будет вычислять матричные выражения,
которые вводятся со стандартного потока ввода. Для этого разрабатывается 
свой язык матричных вычислений. Предполагается, что у нас матрицы 
рациональных чисел (см. предыдущее задание). Над матрицами и векторами 
можно производить вычисления, которые могут быть присвоены другим матрицам 
и векторам. Матрицы  и вектора можно описывать как переменные. При помощи 
специальных конструкций можно читать из файлов или писать в файлы. Так же
их можно распечатывать в стандартный поток вывода. 

Предполагается, что пользователь может написать некоторый текстовый файл
(программу для интерпретатора) который направит на вход интерпретатору, 
подобно shell скрипту в bash.

Требуется представить грамматику для лексического разбора в виде 
текстового файла в формате, описанным в конце текста данного задания, 
либо на бумаге. А для синтаксического разбора требуется представить файл 
в синтаксисе Gnu bison. Cм. 
\href{https://www.gnu.org/software/bison/manual/html_node/Grammar-File.html#Grammar-File}%
{документацию на описание файлов грамматики Gnu Bison}.

\section{Описание языка}

Программа может содержать комментарии в виде конструкций 
с решёточкой и комментарии языка Си.

\subsection{Декларации}

В начале идёт Секция Деклараций переменных. Она начинается с ключевого слова 
\textit{declare:}. далее разделённые пробельными символами, в том числе возможно,
переносами строк следуют описания переменных. Описание переменных производятся 
подобно тому, как это происходит в C++. Сперва указывается тип переменной: 
\textit{integer}, \textit{float}, \textit{rational}, \textit{vector}, \textit{matrix}. Далее после `:' 
список переменных, с возможной инициализацией значений в виде 
параметров конструктору (см. предыдущее задание). Имя переменной 
-- идентификатор языка Cи. Элементы в списке разделены запятыми, 
заканчивается он символом `;'. Если у чисел не указано значение, 
то они должны быть инициализированы нулём.

Далее представлен 
пример такого описания переменных.

\begin{verbatim}
declare:
    #
    # Описания матричных переменных
    #
    matrix: a,b, c("c_sparse_mtr.txt"),
            D("D sparse mtr\"pseudo\".txt");

    vector: v1,v2 ("../vector_sparse.txt");

    rational:
        number1(1), number2(-10 / 3), number3 ;

    /*
     * представлять как double в программе
     */
    float: f(0.99999999);
    integer: i,j,k(10);

\end{verbatim}

\subsection{Выражения}

Далее следует блок, выражений. Выражения начинаются с конструкции 
\textit{process:}.
В выражениях допустимо указание скобочек, а так же операций присвоения.
Приоритет операций естественный для языка программирования C++.
Допускаются конструкции доступа к элементам матрицы и вектора через
квадратную скобку. Например так: \textit{v1[3]} и \textit{c[6000,2]}.

Через двоеточие, в выражениях могут быть указаны действия над объектами.
Общие для всех это: \textit{read("имя файла")}, \textit{write("имя файла")},
\textit{print}. Действия \textit{read}, \textit{write} 
предполагают чтение и запись в файл, \textit{print} распечатку в объекта 
в стандартный поток вывода.

Также должна присутствовать функция \textit{info}, 
которая распечатывает строку. При этом строка не привязана ни к какому
объекту, в отличии от \textit{print}. Может встречаться в любом месте
выражения и печать происходит в момент, когда процесс выполнения достигает
данное место.

Для векторов и матриц дополнительно определено действие
\textit{rotate}, Которое меняет ориентацию вектора c с горизонтальной
на вертикальную  в выражениях, и  для матриц оно транспонирует матрицу.

Для матриц определены действия \textit{row(номер строки)} и 
\textit{column(номер столбца)}, которые возвращают строку и 
столбец матрицы соответственно.

Для рациональных чисел, матриц и векторов, должно быть определено действие
\textit{make{\textunderscore}canonical}.

Приоритет действия выше любой другой операции, например сложения или
умножения.

В случае, если присвоение происходит переменной типа \textit{integer}
или \textit{float} необходимо произвести соответствующие преобразования 
типов.

Далее следует пример выражений.

\begin{verbatim}
process:
    a=(b+c info("сложили\n") ) * (E = D ^ num2) :rotate ;
    m=v1:rotate * v2;
    r=m[1,2];

    info("всем привет\n");

    r: write("лес.txt");

    number1=r;

    E: print;  E: write("hz.txt");

\end{verbatim}

\section{Замечания по реализации}

При реализации, предполагается, что будут задействованы классы предыдущего
задания. В случае ошибочной ситуации, например объекты класса генерируют
исключение, все такие события, должны быть напечатаны на стандартный поток 
ошибок, с описанием ошибки, её предполагаемой причины, а также координат 
в файле (строка : колонка) на которой случилась ошибка.


\section{Язык описания грамматики для лексического разбора}

Для лексического разбора опишем грамматику в следующих предположениях накладываемых
на правила грамматики:
\begin{itemize}
    \item $\ls{A} \to \neg {'a'} | \neg {'a'} \ns{B}$ -- любой символ кроме 
        символа $a$.
    \item $\ls{A} \to . | . \ns{B}$ -- любой символ.
    \item $\ls{A} \to 'a' | ... | 'z'$ -- все символы от a до z.
    \item $\ls{A} \to "word"$ -- это сокрытие набора правил, 
        которые задают определённое слово.
    \item $\ls{A} \to \neg('a''b')$ - группировка символов для применения операции.
    \item $\ls{A} \to \ns{B} $ -- пустые правила, которые делают грамматику 
        не автоматной, но нужны для повышения читаемости грамматики.
        Грамматика с такими правилами легко приводится к каноническому 
        виду регулярной грамматики путём внесения в правую часть правила $A$
        всех правых частей правила $B$.
\end{itemize}

\end{document}
